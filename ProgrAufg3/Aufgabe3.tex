\documentclass[11pt,titlepage]{article}

%Laenderspezifische Einstellungen bzgl. Rechtschreibung, Sonderzeichen und Kodierung
\usepackage[utf8]{inputenc}
\usepackage[naustrian]{babel}
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{graphicx}
%\usepackage{subcaption}

\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\usepackage{matlab-prettifier}
\definecolor{light-gray}{gray}{0.85}
\lstset{
language=C++,
numbers=left,
style=Matlab-editor,
basicstyle=\mlttfamily,
breaklines=true,
backgroundcolor=\color{light-gray},
tabsize=2,
basicstyle=\footnotesize\ttfamily,
frame=single,
inputencoding=utf8,
extendedchars=true,
showstringspaces=false,
literate =
	{ä}{{\"a}}1
	{ö}{{\"o}}1
	{ü}{{\"u}}1
	{Ä}{{\"A}}1
	{Ö}{{\"O}}1
	{Ü}{{\"U}}1
	{ß}{{\ss}}1
	{ₙ}{{$_n$}}1
}

\def\ContinueLineNumber{\lstset{firstnumber=last}}
\def\StartLineAt#1{\lstset{firstnumber=#1}}

\usepackage[
	a4paper,
	top = 2cm,
	bottom = 2 cm,
	left = 2cm,
	right = 2cm,
	headheight = 15pt,
	includeheadfoot
	]{geometry}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[english]{varioref}
\usepackage{hyperref}

\fancypagestyle{fancy}{
	\fancyhead[R]{Page \thepage}
	\fancyhead[L]{\leftmark}
	\renewcommand{\headrulewidth}{1.25pt}

	\fancyfoot[L]{\tiny{Num. Ana. - Übung 3 , created: \today}}
	\fancyfoot[R]{\tiny{Felix Dreßler (k12105003), Elisabeth Köberle (k12110408), Ricardo Holzapfel (k11942080)}}
	\cfoot{}
	\renewcommand{\footrulewidth}{1.25pt}
}

\setlength{\headsep}{10mm}
\setlength{\footskip}{10mm}

\setlength{\parindent}{0mm}
\setlength{\parskip}{1.1ex plus0.25ex minus0.25ex}
\setlength{\tabcolsep}{0.2cm} % for the horizontal padding

\pagestyle{fancy}

\title{Num. Ana. - Übung 2}
\author{Felix Dreßler (k12105003) \\ Elisabeth Köberle (k12110408) \\ Ricardo Holzapfel (k11942080)}
\date{\today} %Erstellungsdatum

\begin{document}
\maketitle
	
	\section{gedämpftes Newton-Verfahren}
		Im folgenden die Implementierung des gedämpften Newton-Verfahrens. Die Wahl von $maxIter$ basiert auf den unten angeführten Tests und gibt eine realistische obere Schranke für Konvergenz des Verfahrens. (genaueres zu F2 in den Resultaten)
		Der Wert $mu$ wird im Abbruchskriterium verwendet. Es muss gelten $mu \in [0,1]$. Die Wahl von $ mu = 0.1$ basiert auf einer Empfehlung des Skripts.
	
		\lstinputlisting{solveEq.m}


\newpage
	\section{Testfunktion 1}
		Wir testen nun die Funktion F1 aus der Angabe mit Startvektor $ x0 = \begin{pmatrix} 10 \\ 10\end{pmatrix} $
		
		\begin{lstlisting}
			>> [x, exitflag, iter, f_eval] = solveEq(@F1, x0)
			
			x =
			
			-2.772012301967051
			2.039147038513721
			
			
			exitflag =
			
			0
			
			
			iter =
			
			16
			
			
			f_eval =
			
			18
		\end{lstlisting}
	
		Im Vergleich mit fsolve ergibt sich:
		
		\begin{lstlisting}
			>> fsolve(@F1, [10,10]')
			ans =
			
			-2.7720
			2.0391
			
		\end{lstlisting}
		
		Die beiden Lösungen liegen also sehr Nahe beieinander.
		
	\section{Testfunktion2}
		Wir testen nun die Funktion F2 aus der Angabe mit Startvektor $ x0 = \begin{pmatrix} 10 \\ 10 \\ 10 \\10 \end{pmatrix} $
		
		\begin{lstlisting}
			
		\end{lstlisting}
		
		Im Vergleich mit fsolve ergibt sich:
		
		\begin{lstlisting}
			>> fsolve(@F2, [10, 10, 10, 10]')
			ans =
			
			4.8482
			5.2704
			23.5149
			3.4195	
		\end{lstlisting}
		
	\section{Testfunktion3}
		Nun testen wir die Funktion $ f(\begin{pmatrix} x \\ y \end{pmatrix}) = \begin{pmatrix} sin(x) \\ cos(y) \end{pmatrix}$
		Dazu wurde folgende MatLab-Funktion verwendet:
		\begin{lstlisting}
			function [F, DF] = testFun(x)
			% n = 2    
			F= zeros(2,1);
			F(1) = sin(x(1));
			F(2) = cos(x(2));
			DF = zeros(2,2);
			DF(1,1)=cos(x(1));
			DF(1,2)= 0;
			DF(2,2)=-sin(x(2));
			DF(2,1)=0;    
			
			end
		\end{lstlisting}
		
		Im folgenden noch die Tests:
		
		\begin{lstlisting}
			>> [x, exitflag, iter, f_eval] = solveEq(@testFun, x0)
			
			x =
			
			9.424777960769379
			10.995574287564276
			
			
			exitflag =
			
			0
			
			
			iter =
			
			5
			
			
			f_eval =
			
			6
		\end{lstlisting}
		
		Im Vergleich mit fsolve ergibt sich:
		
		\begin{lstlisting}
			>> fsolve(@testFun, [10, 10]')
			ans =
			
			9.4248  
			10.9956
		\end{lstlisting}
	
		Wir erhalten also einen sehr ähnlichen Wert.
	
	\section{Testfunktion4}
		Nun testen wir die eindimensionale Funktion $ f(x) = e^{-x}$
		Dazu wurde folgende MatLab-Funktion verwendet:
		\begin{lstlisting}
			function [F, DF] = slowFun(x)
			% n = 1  
			F = exp(-x);
			DF = -exp(-x);
			end
		\end{lstlisting}
	
		Im folgenden noch die Tests:
		
		\begin{lstlisting}
			>> [x, exitflag, iter, f_eval] = solveEq(@slowFun, 10)
			
			x =
			
			35
			
			
			exitflag =
			
			0
			
			
			iter =
			
			25
			
			
			f_eval =
			
			26
		\end{lstlisting}
		
		Im Vergleich mit fsolve ergibt sich:
		
		\begin{lstlisting}
			>> fsolve(@slowFun, 10)
			ans = 12.000
		\end{lstlisting}
	
		hier erhalten wir unterschiedliche Nullstellen (obwohl die Funktion natürlich keine Nullstelle hat). Das liegt vermutlich an einer anderen Genauigkeit der fsolve Funktion im Vergleich zu unserer Implementierung
		
	\section{Testfunktion5}
		Nun testen wir die eindimensionale Funktion $ f(x) = 0$
		Dazu wurde folgende MatLab-Funktion verwendet:
		\begin{lstlisting}
			function [ F, DF ] = zero( x )
			% n = 1
			F = 0;
			DF = 0;
			end
		\end{lstlisting}
		Diese Funktion ist interessant weil wir natürlich keine Iteration brauchen, wenn unser Ausgangswert bereits eine Nullstelle ist.
	
		Im folgenden noch die Tests:
		
		\begin{lstlisting}
			>> [x, exitflag, iter, f_eval] = solveEq(@zero, 10)
			
			x =
			
			10
			
			
			exitflag =
			
			0
			
			
			iter =
			
			0
			
			
			f_eval =
			
			1
		\end{lstlisting}
		
		Im Vergleich mit fsolve ergibt sich:
		
		\begin{lstlisting}
			>> fsolve(@zero, 10)
			ans = 10
		\end{lstlisting}
	
			Klarerweise geben beide Funktionen wieder x0 zurück.
	
	\section{Testfunktion6}
		Nun testen wir die eindimensionale Funktion $ f(x) = x^2 + 1$
		Dazu wurde folgende MatLab-Funktion verwendet:
		\begin{lstlisting}
			function [ F, DF ] = noRoot( x )
			% n = 1
			F = x.*x + 1;
			DF = 2.*x;
			end
		\end{lstlisting}
		Diese Funktion besitzt keine Nullstelle, deshalb sollten wir hier nach der maximalen Iterationszahl auch abbrechen.
	
		Im folgenden noch die Tests:
		
		\begin{lstlisting}
			>> [x, exitflag, iter, f_eval] = solveEq(@noRoot, 10)
			
			x =
			
			6.101667877118361e-09
			
			
			exitflag =
			
			1
			
			
			iter =
			
			30
			
			
			f_eval =
			
			425
		\end{lstlisting}
		
		Im Vergleich mit fsolve ergibt sich:
		
		\begin{lstlisting}
			>> fsolve(@noRoot, 10)
			ans = -2.0678e-05
		\end{lstlisting}
	
			Obwohl die Funktion keine Nullstelle besitzt erhalten wir bereits gut Approximationen für das Minimum ($x=0$) der Funktion. 

		
	\section{Resultate}
		Testfunktion 6 gibt Grund zur Vermutung, dass das Verfahren in manchen Fällen gegen ein Minnimum der Funktion konvergiert, falls keine Nullstelle vorhanden ist. 
		
		
		Versucht man verschiedene Werte für $mu$ wird die Eingabefunktion $fun$ weniger oft aufgerufen. Das führt bei nicht-Konvergenz dann auch zu einem schnelleren Abbruch. Im folgenden zwei Versuche mit unterschiedlichen $mu$:
		
		$mu = 0.1$
		\begin{lstlisting}
			[x, exitflag, iter, f_eval] = solveEq(@F1, transpose(x0))
			
			x =
			
			-2.7720
			2.0391
			
			
			exitflag =
			
			0
			
			
			iter =
			
			16
			
			
			f_eval =
			
			18
			
			
			
			>> [x, exitflag, iter, f_eval] = solveEq(@noRoot, 10)
			
			x =
			
			6.1017e-09
			
			
			exitflag =
			
			1
			
			
			iter =
			
			30
			
			
			f_eval =
			
			425
			
			
		\end{lstlisting}
	
	
		$mu = 0.5$
		\begin{lstlisting}
			>> [x, exitflag, iter, f_eval] = solveEq(@F1, transpose(x0))
			
			x =
			
			-2.7720
			2.0391
			
			
			exitflag =
			
			0
			
			
			iter =
			
			16
			
			
			f_eval =
			
			18
			
			>> [x, exitflag, iter, f_eval] = solveEq(@noRoot, 10)
			
			x =
			
			1.1243e-07
			
			
			exitflag =
			
			1
			
			
			iter =
			
			30
			
			
			f_eval =
			
			287
			
		\end{lstlisting}

		
			
\end{document}